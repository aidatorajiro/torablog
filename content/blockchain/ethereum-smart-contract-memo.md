---
title: Ethereum スマートコントラクトメモ
date: 2017-12-27T12:31:00+09:00
tags: ["Ethereum", "Smart Contract"]
draft: true
---

Ethereumのスマートコントラクトをいじってみた時のメモ。

## スマートコントラクト？Ethereum？

## Ethereumにおけるアカウントの種別

## DAppのシステム構成

クライアントサイドの立ち位置とか。
コントラクトはAPIのようなものとして働く

## Solidity

solidityの説明

### 構文

Cっぽい。

- now
  **現在ブロックのタイムスタンプ**を取得する。現在時刻ではない。(ブロックチェーン上で実行しているので当たり前といえば当たり前)

- msg.sender
  現在実行中の関数を**呼び出した**アドレス。**Ethereumでは、コントラクトがコントラクトを呼び出すことができるが、その場合は呼び出したコントラクトのアドレスになる。**(ex. ユーザー → コントラクトA → コントラクトB、の順に呼び出された時、コントラクトB内でのmsg.senderはAのアドレスになる。)

- tx.origin
  上記のmsg.senderとは違い、関数コールの連鎖を引き起こした元のアドレス、つまりユーザのアドレスを取得する。コントラクトアドレスはtx.originにはなれない。

tx.originはマイナーが偽装できてしまうため、通常、アドレスを取得したい場合はmsg.senderを使うらしい。
また、アドレス取得にmsg.senderを使っておけば、コントラクトアドレスが関数を自動で呼ぶことができるので、そういう意味でもmsg.senderを使った方が良い。Multisig対応にもなるし(要検証)

### コントラクトの移行

先ほどのDAppのシステム構成で、コントラクトのアドレスはクライアントサイドにハードコードされる、と書いた通り、基本はアップデートのたびに別のコントラクトを作り、そのたびにアプリケーション内のコントラクトアドレスを変更する、という形で良い。

ただ、それだけだと問題が発生する。コントラクトは移行できたから良いものの、肝心のデータが移行できない。新しくコントラクトを作り直すと、内部のデータは全て一度リセットされるからだ。これを回避するために、データベース用のコントラクトを別に作り、その書き込み権限をコントラクトがアップデートされるたびに、最新のコントラクトに設定する、という方法をとる。

具体的には以下のようなコードになる。

```
```

図式化するとこんな感じ

これ以外にも色々と方法があるらしいが、詳しくは"solidity updatable contract"とかでググって！

## Ethereumはコンピューティングプラットフォーム？
