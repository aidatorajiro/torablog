---
title: ReflexでSPA作ってみる
date: 2018-06-13T16:47:00+09:00
---

Haskell製のWebアプリケーションフレームワークの一つに、Reflexというものがある。今回はそれを使ってSPA(Single Page Application)を実装してみる。

SPAと呼ばれるWebアプリケーションの設計方式では、まず始めにブラウザは単一のHTMLファイルをダウンロードして、その後、Javascriptを用いてアクセス先のURLを取得し、ブラウザ側でURLに応じたページを描画する。サーバの内部情報を取得したい場合は、その都度サーバにリクエストする。

## GHCJSとReflex

HaskellコンパイラのひとつであるGHCは、以下のような仕組みでプログラムを機械語に変換している。[^1]

![](/static/HscPipe2.png)

これを見ると、処理の最後の方ではSTG形式 -> Cmm形式 -> 機械語の順で変換していることがわかるが、このSTGという中間言語になったところで、それをJavascriptに翻訳するコンパイラがGHCJSだ。[^2]

さらに、HaskellのFRPフレームワークとしてReflexというものがあり、それをGHCJSに対応させてDOM、すなわちHTMLの動的な操作ができるようになったのがReflex-DOMだ。今回はこのReflexとReflex-DOMを用いて、SPAを構築する。

他のフロントエンド界のライブラリ・フレームワーク群と同様、かなりソフトウェア同士の関係が複雑になっている...

## FRPとは？

ReflexはFRP(Functional Reactive Programming)フレームワークであると謳っている。

FRPとは何だろうか？これは、ある一つの値が変わると、それに関係した=それによって定義された他の値も自動的に変わるということだ。

FRPの観念的な例として以下のコードを挙げる。(これはReflexのコードではない。あくまで観念的なもの。)
```javascript
x = 8
y = x + 1
x += 1
```

このプログラムを普通に解釈してみる。

まず最初に`x`に`8`が代入される。`x + 1`が計算され、それが`y`に代入される。その後`x`が`1`加算されるが、`y`には影響がない。最終的には、`x = 9`、`y = 9`になる。

では次に、全く同じコードを、FRP的に解釈してみよう。上記のコードはこのように解釈される。

まず最初に`x`を`8`と定義する。`y`を`x + 1`と定義する。`x`に`1`加算されるが、ここでさきほど`y`を`x`で定義したので、`y`の値を現在の`x`の値を用いて再計算する。最終的には、`x = 9`、`y = 10`になる。

FRPの重要な点は、式がそのまま恒真な命題となることだ。上記のコードにおいて、普通な解釈では`y = x + 1`は2行目までは成り立つが、3行目からは成り立たない。しかしFRP的な考え方では、`y = x + 1`はどんな場合でも成り立つ。そのように`y`が定義され、値を自動で更新するプログラムが裏で動いているからだ。

本当は、FRPにおいて上記コード内の`x += 1`という部分は、外の世界(ユーザの入力, 乱数, 時刻etc)に関係する部分である。なぜなら、そういった不確定要素がなければ、初めから全ての変数の値が計算できてしまい、変数を更新する必要がないからである。たとえば、ボタンAを押すたび`x += 1`、1秒ごとに`x += 1`と言った具合だ。すなわち、`x`は`8 + ボタンAの押された回数`や`8 + 経過秒数`として定義される。こう考えると、FRPとはすなわち外の世界によって変化する値の定義(の集合)であることがわかる。ある意味では、外の世界が一つのプリミティブな変数であり、それを"加工"し、外の世界が関係する変数を作り上げることがFRPであるとも言える。Reflexの場合、最終的に生成するべきものは動的に変化するページである。それを、外の世界を"加工"して定義するのだ。

たとえHaskellのような関数型言語であっても、外の世界が関係する部分は、どうしても手続き的な表現をする他ない。ユーザの入力を待つ -> `x`を更新する -> `y`を更新する、といったように。しかしFRPでは、ユーザの入力や時間経過が関係する部分でさえ、それらを加工するような方法で、定義的=関数的=Functionalに書ける。もちろん、内部では手続き的な表現でプログラムが動いているのだけれど(最終的にはJavascriptに変換されるから当たり前だ)、Reflexはそれを関数的に記述できるインターフェースを用意してくれている。

FRPのもっとわかりやすい例として、Excelが挙げられる。Excelでは、あるセルの計算式に関係する部分を変更すると、自動的にセルの内容が再計算され、更新される。たとえば、A11をA1からA10までの数値の和(`A11 = SUM(A0:A10)`)としてやると、A1からA10までの数値をユーザが変更するたびに、A11の内容が再計算される。

## ReflexとReflex-DOMの仕組み

ReflexとReflex-DOMの仕組みは、以下のページでとてもわかりやすく説明されている。

<https://github.com/hansroland/reflex-dom-inbits/blob/master/tutorial.md>

Reflexでは、4つの重要な概念が登場する。`Widget`、`Dynamic`、`Event`、`Behavior`だ。

- `Widget` - HTML要素の事。`Dynamic`の値に応じて内容を動的に変化させることができる。
  例えば、`el 'span' (dynText x)`は、内容が`x`のspan要素のこと。`x = 'test'`の時、`<span>text</span>`になる。`x`の値が変化するごとに、span要素の内容も連動して変化する。
- `Dynamic` - 変数の事。
- `Event` - 
- `Behavior` - 

## SPAを作る

SPAは、一つのHTMLファイルにサーバへの全通信を繋げて、HTML内のJavascriptが接続パス等の情報をもとにサイトのルーティングをするという仕組み。

そもそも、ルーティングとはなんだろう？

再帰させなければいけない

再帰で一旦書く

mdo記法つかう

では、ルーティングという概念の数学的構造を理解したところで、実際にそれをReflexのコードに落とし込んでみる。まずは最初に、結論となるコードを記す。

```haskell
import Reflex.Dom
import Reflex.Dom.Location ( getLocationPath )

main :: IO ()
main = do
  init_loc <- getLocationPath
  mainWidget $ mdo
    ee <- dyn $ (\l -> pushState l >> router l) <$> loc
    be <- hold never ee
    loc <- holdDyn init_loc (switch be)
    return ()
```

ここで`router l`関数は、パスlに対応するWidgetを生成する。`pushState l`関数は、HTML5 History APIのpushState関数を呼び、ブラウザの履歴にパスlを追加する。

coincidenceで詰んだ -> hold & switchを使おう

## 感想
Haskellやその周辺のフレームワークは我々に数学的（？）思考を強いてくるから非常にめんどくさい　でもそこがいい！

[^1]: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/HscPipe
[^2]: https://github.com/ghcjs/ghcjs/wiki/Architecture